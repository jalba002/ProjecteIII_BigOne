using System;
using System.Collections.Generic;
using UnityEditor.Experimental.TerrainAPI;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Events;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.XR;

namespace World.Objects
{
    public class DynamicObject : InteractableObject
    {
        #region Declarations

        [System.Serializable]
        public struct DoorHingeConfiguration
        {
            public float maximumAngle;
            public float minimumAngle;
            public float minimumLockedAngle;
            public float maximumLockedAngle;
            [Range(0f, 100f)] public float friction;
            public string fmodPath;
        }

        [System.Serializable]
        public struct DrawerHingeConfiguration
        {
            public float maximumDistance;
            [Range(0f, 100f)] public float friction;
            public float maximumForce;
            public string fmodPath;
        }

        [System.Serializable]
        public struct PalletConfiguration
        {
            public float forceToThrow;
            public float forceScaleApplied;
            public string fmodPath;
        }

        // Object type.
        // Changes the hinge used.
        public enum ObjectType
        {
            Door,
            Drawer,
            Pallet
        }

        // If the door is closed by a key or not.
        public enum LockedMode
        {
            Locked,
            Unlocked
        }

        // If the door is closed and must be opened by turning the handle.
        public enum OpenState
        {
            Closed,
            Opened
        }

        #endregion

        #region MainConfiguration

        [Header("Main Configuration", order = 0)]
        public ObjectType objectType;

        public LockedMode lockedMode;

        public OpenState openState;

        public DoorHingeConfiguration doorConfiguration = new DoorHingeConfiguration()
        {
            friction = 1f,
            maximumAngle = 90f,
            minimumAngle = 0f,
            minimumLockedAngle = -2f,
            maximumLockedAngle = 2f,
            fmodPath = "event:/SFX/Environment/Interactable/DoorLockedTry"
        };

        public DrawerHingeConfiguration drawerConfiguration = new DrawerHingeConfiguration()
        {
            friction = 10f,
            maximumDistance = 0.25f,
            maximumForce = 5f,
            fmodPath = ""
        };

        public PalletConfiguration palletConfiguration = new PalletConfiguration()
        {
            forceToThrow = 100f,
            forceScaleApplied = 5f,
            fmodPath = "event:/SFX/Player/LiftingWardrobeEffortIntro"
        };

        #endregion

        [Header("Hinge Settings", order = 1)] public GameObject HandlePosition;
        public bool applyHandleRotation = false;
        public float openForce = 5f;
        private Quaternion originalHandleRotation;
        [Range(1f, 15f)] public float maxMouseInput = 3f;
        public bool UseMouseXAxis = false;
        public bool InvertInitialization = false;
        [Range(0f, 1f)] public float StartupClosePercentage = 0.96f;

        [Header("Rigidbody Settings")] public bool useGravity = false;

        [Header("Sound")]
        [Tooltip("If this is not null or void, this sound will be played instead of the default one.")]
        public string fmodSoundOverride = "";

        [Space(2)] [Header("Collision Settings")]
        public bool ignorePlayerCollider = false;

        public bool autoGenerateColliders = false;
        public LayerMask autoGeneratedCollidersMask;
        [Range(0f, 5f)] public float autoGeneratedCollidersRange = 1.5f;

        [Space(5)] public List<Collider> ignoredColliders;
        private Collider selfCollider;

        // Joints.
        public HingeJoint HingeJoint { get; set; }
        public ConfigurableJoint ConfgJoint { get; set; }

        [Header("Events")] public UnityEvent OnUnlockEvent = new UnityEvent();
        public UnityEvent OnStartInteracting = new UnityEvent();

        public Rigidbody Rigidbody { get; protected set; }

        public void Awake()
        {
            GetRigidbody();

            selfCollider = gameObject.GetComponent<Collider>();

            GetJoints(objectType);

            GenerateIgnoredColliders(selfCollider);
            if (HandlePosition == null)
            {
                throw new NullReferenceException($"Missing Handle in {this.gameObject.name}");
            }
        }

        public void Start()
        {
            IgnoreColliders();
            SetJointsLimit(lockedMode);
            SetInitialPositions();
            OnUnlockEvent.AddListener(OnUnlock);
            originalHandleRotation = HandlePosition.transform.rotation;
        }

        private void SetInitialPositions()
        {
            switch (objectType)
            {
                case ObjectType.Drawer:
                    Vector3 newStartingPosition = this.gameObject.transform.localPosition;
                    Vector3 forward =
                        HandlePosition.transform.InverseTransformDirection(HandlePosition.transform.forward);
                    newStartingPosition += (InvertInitialization ? -forward : forward) *
                                           (drawerConfiguration.maximumDistance * StartupClosePercentage);
                    this.gameObject.transform.localPosition = newStartingPosition;
                    break;
                case ObjectType.Door:
                    break;
                case ObjectType.Pallet:
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        private void GetRigidbody()
        {
            Rigidbody = GetComponent<Rigidbody>();
            if (Rigidbody == null)
            {
                Rigidbody = gameObject.AddComponent<Rigidbody>();
            }

            Rigidbody.useGravity = useGravity;
            Rigidbody.angularDrag = 0f;
            Rigidbody.drag = objectType == ObjectType.Door
                ? doorConfiguration.friction
                : (objectType == ObjectType.Drawer ? drawerConfiguration.friction : Rigidbody.drag);
            return;
        }

        #region Joints

        private void GetJoints(ObjectType objectType)
        {
            switch (objectType)
            {
                case ObjectType.Door:
                case ObjectType.Pallet:
                    HingeJoint = gameObject.GetComponent<HingeJoint>();
                    if (HingeJoint == null)
                    {
                        HingeJoint = gameObject.AddComponent<HingeJoint>();
                        ConfigureNewJoint(HingeJoint);
                    }

                    break;
                case ObjectType.Drawer:
                    ConfgJoint = gameObject.GetComponent<ConfigurableJoint>();
                    if (ConfgJoint == null)
                    {
                        ConfgJoint = gameObject.AddComponent<ConfigurableJoint>();
                        ConfigurateNewJoint(ConfgJoint);
                    }

                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(objectType), objectType, null);
            }
        }


        private void ConfigurateNewJoint(ConfigurableJoint joint)
        {
            joint.xMotion = ConfigurableJointMotion.Locked;
            joint.yMotion = ConfigurableJointMotion.Locked;
            joint.zMotion = ConfigurableJointMotion.Limited;
            joint.angularXMotion = ConfigurableJointMotion.Locked;
            joint.angularYMotion = ConfigurableJointMotion.Locked;
            joint.angularZMotion = ConfigurableJointMotion.Locked;
        }

        private void ConfigureNewJoint(HingeJoint joint)
        {
            joint.anchor = new Vector3(.5f, .5f, .5f);
            joint.axis = new Vector3(0f, 1f, 0f);
            joint.useLimits = true;
            joint.useSpring = true;
            joint.autoConfigureConnectedAnchor = true;
            //joint.anchor = new Vector3(0f, -0.5f, 0f);
        }

        private void CheckObjectOpening()
        {
            switch (objectType)
            {
                case ObjectType.Door:

                    break;
                case ObjectType.Drawer:
                    break;
                case ObjectType.Pallet:
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        private void SetJointsLimit(LockedMode lockMode)
        {
            switch (lockMode)
            {
                case LockedMode.Locked:
                    switch (objectType)
                    {
                        case ObjectType.Door:
                            if (HingeJoint == null) return;
                            HingeJoint.limits = new JointLimits()
                            {
                                max = doorConfiguration.maximumLockedAngle,
                                min = doorConfiguration.minimumLockedAngle
                            };
                            break;
                        case ObjectType.Drawer:

                            break;
                        default:
                            throw new ArgumentOutOfRangeException(nameof(objectType), objectType, null);
                    }

                    break;
                case LockedMode.Unlocked:
                    switch (objectType)
                    {
                        case ObjectType.Door:
                            if (HingeJoint == null) return;
                            HingeJoint.limits = new JointLimits()
                            {
                                max = doorConfiguration.maximumAngle,
                                min = doorConfiguration.minimumAngle
                            };
                            /*HingeJoint.spring = new JointSpring()
                            {
                                damper = DoorJointConfiguration.friction
                            };*/
                            break;
                        case ObjectType.Drawer:
                            if (ConfgJoint == null) return;
                            ConfgJoint.linearLimit = new SoftJointLimit()
                            {
                                limit = drawerConfiguration.maximumDistance,
                                contactDistance = 1000f
                            };
                            /*ConfgJoint.linearLimitSpring = new SoftJointLimitSpring()
                            {
                                damper = DrawerJointConfiguration.friction
                            };*/
                            ConfgJoint.zDrive = new JointDrive()
                            {
                                maximumForce = drawerConfiguration.maximumForce,
                                //positionDamper = DrawerJointConfiguration.friction
                            };
                            break;
                        case ObjectType.Pallet:
                            // Debug.LogWarning("No pallet configurations!");
                            /*HingeJoint.limits = new JointLimits()
                            {
                                
                            }*/
                            break;
                        default:
                            throw new ArgumentOutOfRangeException(nameof(objectType), objectType, null);
                    }

                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            lockedMode = lockMode;
        }

        public void BreakJoint(Collider instigator = null)
        {
            Destroy(HingeJoint);
            Destroy(GetComponent<NavMeshObstacle>());
            Rigidbody.drag = 0f;
            Rigidbody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
            if (instigator != null)
            {
                Physics.IgnoreCollision(this.gameObject.GetComponent<Collider>(), instigator, true);
            }

            this.gameObject.layer = 0;
        }

        #endregion

        #region IgnoreColliders

        private bool GenerateIgnoredColliders(Collider selfCollider)
        {
            try
            {
                if (autoGenerateColliders)
                {
                    if (showLogDebug)
                        Debug.Log("Ignoring nearby colliders.", this);
                    Collider[] collectedColliders = Physics.OverlapSphere(this.gameObject.transform.position,
                        autoGeneratedCollidersRange, autoGeneratedCollidersMask);
                    foreach (Collider collider in collectedColliders)
                    {
                        if (collider != selfCollider)
                        {
                            if (showLogDebug)
                                Debug.Log($"Added {collider.gameObject.name} to the list");
                            ignoredColliders.Add(collider);
                        }
                    }
                }

                if (ignorePlayerCollider)
                {
                    if (showLogDebug)
                        Debug.Log("Ignoring Player Collider.");
                    if (GameManager.Instance.PlayerController != null)
                    {
                        if (showLogDebug)
                            Debug.Log("Player Collider Not Null.");
                        ignoredColliders.Add(GameManager.Instance.PlayerController.attachedCollider);
                    }
                }
            }
            catch (NullReferenceException)
            {
                Debug.LogWarning("Ignored colliders generated wrongly in ", this.gameObject);
                return false;
            }

            return true;
        }

        private void IgnoreColliders()
        {
            List<Collider> toRemoveColliders = new List<Collider>();
            foreach (Collider currentCollider in ignoredColliders)
            {
                if (currentCollider == null || currentCollider.Equals(null))
                {
                    if (showLogDebug)
                        Debug.Log($"Removing null collider {currentCollider}");
                    toRemoveColliders.Remove(currentCollider);
                }
                else
                {
                    if (showLogDebug)
                        Debug.Log($"Ignoring {currentCollider.gameObject.name} with {selfCollider.gameObject.name}");
                    Physics.IgnoreCollision(currentCollider, selfCollider, true);
                }
            }

            foreach (Collider VARIABLE in toRemoveColliders)
            {
                ignoredColliders.Remove(VARIABLE);
            }
        }

        #endregion

        #region Interactable

        public override void UpdateInteractable()
        {
            base.UpdateInteractable();
            if (IsInteracting)
            {
                OnInteracting();
            }
        }

        // Interface Implementation //
        public bool ForceClose()
        {
            throw new NotImplementedException();
        }

        public bool Unlock()
        {
            SetJointsLimit(LockedMode.Unlocked);
            OnUnlockEvent.Invoke();
            return true;
        }

        public void SetUnlock()
        {
            Unlock();
        }

        private void OnUnlock()
        {
            // TODO Play sound depending on the type? 
            SoundManager.Instance.PlayOneShotSound("event:/SFX/Environment/Interactable/DoorUnlocked",
                transform.position);
        }


        public bool Lock()
        {
            throw new NotImplementedException();
        }

        public bool OnClose()
        {
            throw new NotImplementedException();
        }

        public bool OnOpen()
        {
            throw new NotImplementedException();
        }

        #endregion

        public override bool Interact(bool interactEnable)
        {
            if (!interactEnable)
            {
                OnEndInteract();
                return true;
            }

            if (!IsInteracting)
            {
                OnStartInteract();
                return true;
            }

            return false;
        }

        #region OnInteractions

        public override void OnStartInteract()
        {
            base.OnStartInteract();
            OnStartInteracting.Invoke();

            PlayOpenSound();

            if (Rigidbody == null)
            {
                Rigidbody = GetComponent<Rigidbody>();
                if (!Rigidbody)
                {
                    Debug.LogWarning("No rigidbody was found. Adding a new one.");
                    Rigidbody = gameObject.AddComponent<Rigidbody>();
                    Rigidbody.useGravity = false;
                }
            }

            SetHandleDirection(GameManager.Instance.PlayerController.transform.position);
        }

        public void PlayOpenSound()
        {
            string eventLocation = fmodSoundOverride;
            string defaultSoundLocation = "";

            switch (objectType)
            {
                case ObjectType.Door:
                    defaultSoundLocation = doorConfiguration.fmodPath;

                    /*SoundManager.Instance.PlaySound2D(doorConfiguration
                        .fModPath); //event:/SFX/Environment/Interactable/DoorLockedTry*/
                    break;
                case ObjectType.Drawer:
                    defaultSoundLocation = drawerConfiguration.fmodPath;

                    /*SoundManager.Instance.PlaySound2D(drawerConfiguration
                        .fModPath); //event:/SFX/Environment/Interactable/..*/
                    break;
                case ObjectType.Pallet:
                    defaultSoundLocation = palletConfiguration.fmodPath;

                    /* SoundManager.Instance.PlaySound2D(palletConfiguration
                         .fModPath); //event:/SFX/Player/LiftingWardrobeEffortIntro*/
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            if (fmodSoundOverride != "null")
            {
                try
                {
                    SoundManager.Instance.PlaySound2D(eventLocation);
                }
                catch (Exception e)
                {
                    Debug.LogWarning("Could not play FMOD sound. Playing default sound. (Missing variable or event).",
                        this.gameObject);
                    try
                    {
                        SoundManager.Instance.PlaySound2D(defaultSoundLocation);
                    }
                    catch (Exception error)
                    {
                        Debug.LogWarning("Could not play DEFAULT FMOD Sound. Missing variable or event.",
                            this.gameObject);
                    }
                }
            }
        }


        public override void OnInteracting()
        {
            base.OnInteracting();
            ForceOpen(CalculateForce(openForce));
        }

        public override void OnEndInteract()
        {
            base.OnEndInteract();
        }

        #endregion

        #region Handles

        public void SetHandleDirection(Vector3 position)
        {
            if (!applyHandleRotation) return;

            Transform objectTransform = gameObject.transform;
            Vector3 forwardVector = objectTransform.forward;
            Plane directionPlane = new Plane(forwardVector, objectTransform.position);
            bool playerOnSide = directionPlane.GetSide(position);

            HandlePosition.transform.forward = playerOnSide ? -forwardVector : forwardVector;
        }

        public void ResetHandle()
        {
            HandlePosition.transform.rotation = originalHandleRotation;
        }

        #endregion

        private float CalculateForce(float forceScale = 1f)
        {
            float calculatedForce = 1f;
            float mouseAxis = UseMouseXAxis ? Input.GetAxis("Mouse X") : Input.GetAxis("Mouse Y");
            mouseAxis = Mathf.Clamp(mouseAxis, -maxMouseInput, maxMouseInput);
            calculatedForce = (forceScale * mouseAxis) * OptionsManager.Instance.sensibility;

            return calculatedForce;
        }

        public void ForceOpen(float force)
        {
            var useForce = HandlePosition.transform.forward * force;
            Rigidbody.AddForceAtPosition(useForce, HandlePosition.transform.position, ForceMode.Force);
        }

        #region Opening

        public void StrongOpening()
        {
            var useForce = HandlePosition.transform.forward * (Rigidbody.mass * openForce);
            Rigidbody.AddForceAtPosition(useForce, HandlePosition.transform.position, ForceMode.Impulse);
        }

        public void BreakOpening(Vector3 direction, float force = 10f)
        {
            var useForce = direction * (Rigidbody.mass * force);
            Rigidbody.AddForceAtPosition(useForce, HandlePosition.transform.position, ForceMode.Impulse);
        }

        public void StrongClosing()
        {
            var useForce = HandlePosition.transform.forward * (Rigidbody.mass * openForce);
            Rigidbody.AddForceAtPosition(-useForce, HandlePosition.transform.position, ForceMode.Impulse);
        }

        #endregion

        //Update hinge variables when inspector is modified.
        private void OnValidate()
        {
            SetJointsLimit(lockedMode);
        }
    }
}